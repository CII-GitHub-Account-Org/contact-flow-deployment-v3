import { loadRestJsonErrorCode, parseJsonBody as parseBody, parseJsonErrorBody as parseErrorBody } from "@aws-sdk/core";
import { requestBuilder as rb } from "@smithy/core";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectInt32 as __expectInt32, expectLong as __expectLong, expectNonNull as __expectNonNull, expectNumber as __expectNumber, expectObject as __expectObject, expectString as __expectString, limitedParseDouble as __limitedParseDouble, map, parseEpochTimestamp as __parseEpochTimestamp, serializeFloat as __serializeFloat, strictParseInt32 as __strictParseInt32, take, withBaseException, } from "@smithy/smithy-client";
import { LexModelsV2ServiceException as __BaseException } from "../models/LexModelsV2ServiceException";
import { ConflictException, InternalServerException, PreconditionFailedException, ResourceNotFoundException, ServiceQuotaExceededException, ThrottlingException, ValidationException, } from "../models/models_0";
export const se_BatchCreateCustomVocabularyItemCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/customvocabulary/DEFAULT/batchcreate");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    let body;
    body = JSON.stringify(take(input, {
        customVocabularyItemList: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_BatchDeleteCustomVocabularyItemCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/customvocabulary/DEFAULT/batchdelete");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    let body;
    body = JSON.stringify(take(input, {
        customVocabularyItemList: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_BatchUpdateCustomVocabularyItemCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/customvocabulary/DEFAULT/batchupdate");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    let body;
    body = JSON.stringify(take(input, {
        customVocabularyItemList: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_BuildBotLocaleCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    let body;
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateBotCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots");
    let body;
    body = JSON.stringify(take(input, {
        botMembers: (_) => _json(_),
        botName: [],
        botTags: (_) => _json(_),
        botType: [],
        dataPrivacy: (_) => _json(_),
        description: [],
        idleSessionTTLInSeconds: [],
        roleArn: [],
        testBotAliasTags: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_CreateBotAliasCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/botaliases");
    b.p("botId", () => input.botId, "{botId}", false);
    let body;
    body = JSON.stringify(take(input, {
        botAliasLocaleSettings: (_) => _json(_),
        botAliasName: [],
        botVersion: [],
        conversationLogSettings: (_) => _json(_),
        description: [],
        sentimentAnalysisSettings: (_) => _json(_),
        tags: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_CreateBotLocaleCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    let body;
    body = JSON.stringify(take(input, {
        description: [],
        generativeAISettings: (_) => _json(_),
        localeId: [],
        nluIntentConfidenceThreshold: (_) => __serializeFloat(_),
        voiceSettings: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_CreateBotReplicaCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/replicas");
    b.p("botId", () => input.botId, "{botId}", false);
    let body;
    body = JSON.stringify(take(input, {
        replicaRegion: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_CreateBotVersionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/botversions");
    b.p("botId", () => input.botId, "{botId}", false);
    let body;
    body = JSON.stringify(take(input, {
        botVersionLocaleSpecification: (_) => _json(_),
        description: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_CreateExportCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/exports");
    let body;
    body = JSON.stringify(take(input, {
        fileFormat: [],
        filePassword: [],
        resourceSpecification: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_CreateIntentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    let body;
    body = JSON.stringify(take(input, {
        description: [],
        dialogCodeHook: (_) => _json(_),
        fulfillmentCodeHook: (_) => se_FulfillmentCodeHookSettings(_, context),
        initialResponseSetting: (_) => se_InitialResponseSetting(_, context),
        inputContexts: (_) => _json(_),
        intentClosingSetting: (_) => se_IntentClosingSetting(_, context),
        intentConfirmationSetting: (_) => se_IntentConfirmationSetting(_, context),
        intentName: [],
        kendraConfiguration: (_) => _json(_),
        outputContexts: (_) => _json(_),
        parentIntentSignature: [],
        qnAIntentConfiguration: (_) => _json(_),
        sampleUtterances: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_CreateResourcePolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/policy/{resourceArn}");
    b.p("resourceArn", () => input.resourceArn, "{resourceArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        policy: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateResourcePolicyStatementCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/policy/{resourceArn}/statements");
    b.p("resourceArn", () => input.resourceArn, "{resourceArn}", false);
    const query = map({
        [_eRI]: [, input[_eRI]],
    });
    let body;
    body = JSON.stringify(take(input, {
        action: (_) => _json(_),
        condition: (_) => _json(_),
        effect: [],
        principal: (_) => _json(_),
        statementId: [],
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_CreateSlotCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents/{intentId}/slots");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    b.p("intentId", () => input.intentId, "{intentId}", false);
    let body;
    body = JSON.stringify(take(input, {
        description: [],
        multipleValuesSetting: (_) => _json(_),
        obfuscationSetting: (_) => _json(_),
        slotName: [],
        slotTypeId: [],
        subSlotSetting: (_) => se_SubSlotSetting(_, context),
        valueElicitationSetting: (_) => se_SlotValueElicitationSetting(_, context),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_CreateSlotTypeCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/slottypes");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    let body;
    body = JSON.stringify(take(input, {
        compositeSlotTypeSetting: (_) => _json(_),
        description: [],
        externalSourceSetting: (_) => _json(_),
        parentSlotTypeSignature: [],
        slotTypeName: [],
        slotTypeValues: (_) => _json(_),
        valueSelectionSetting: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_CreateTestSetDiscrepancyReportCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/testsets/{testSetId}/testsetdiscrepancy");
    b.p("testSetId", () => input.testSetId, "{testSetId}", false);
    let body;
    body = JSON.stringify(take(input, {
        target: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateUploadUrlCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/createuploadurl");
    let body;
    body = "";
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteBotCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/bots/{botId}");
    b.p("botId", () => input.botId, "{botId}", false);
    const query = map({
        [_sRIUC]: [() => input.skipResourceInUseCheck !== void 0, () => input[_sRIUC].toString()],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteBotAliasCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/bots/{botId}/botaliases/{botAliasId}");
    b.p("botAliasId", () => input.botAliasId, "{botAliasId}", false);
    b.p("botId", () => input.botId, "{botId}", false);
    const query = map({
        [_sRIUC]: [() => input.skipResourceInUseCheck !== void 0, () => input[_sRIUC].toString()],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteBotLocaleCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteBotReplicaCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/bots/{botId}/replicas/{replicaRegion}");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("replicaRegion", () => input.replicaRegion, "{replicaRegion}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteBotVersionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/bots/{botId}/botversions/{botVersion}");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    const query = map({
        [_sRIUC]: [() => input.skipResourceInUseCheck !== void 0, () => input[_sRIUC].toString()],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteCustomVocabularyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/customvocabulary");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteExportCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/exports/{exportId}");
    b.p("exportId", () => input.exportId, "{exportId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteImportCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/imports/{importId}");
    b.p("importId", () => input.importId, "{importId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteIntentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents/{intentId}");
    b.p("intentId", () => input.intentId, "{intentId}", false);
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteResourcePolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/policy/{resourceArn}");
    b.p("resourceArn", () => input.resourceArn, "{resourceArn}", false);
    const query = map({
        [_eRI]: [, input[_eRI]],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteResourcePolicyStatementCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/policy/{resourceArn}/statements/{statementId}");
    b.p("resourceArn", () => input.resourceArn, "{resourceArn}", false);
    b.p("statementId", () => input.statementId, "{statementId}", false);
    const query = map({
        [_eRI]: [, input[_eRI]],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteSlotCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents/{intentId}/slots/{slotId}");
    b.p("slotId", () => input.slotId, "{slotId}", false);
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    b.p("intentId", () => input.intentId, "{intentId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteSlotTypeCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/slottypes/{slotTypeId}");
    b.p("slotTypeId", () => input.slotTypeId, "{slotTypeId}", false);
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    const query = map({
        [_sRIUC]: [() => input.skipResourceInUseCheck !== void 0, () => input[_sRIUC].toString()],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteTestSetCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/testsets/{testSetId}");
    b.p("testSetId", () => input.testSetId, "{testSetId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteUtterancesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/bots/{botId}/utterances");
    b.p("botId", () => input.botId, "{botId}", false);
    const query = map({
        [_lI]: [, input[_lI]],
        [_sI]: [, input[_sI]],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DescribeBotCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/bots/{botId}");
    b.p("botId", () => input.botId, "{botId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeBotAliasCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/bots/{botId}/botaliases/{botAliasId}");
    b.p("botAliasId", () => input.botAliasId, "{botAliasId}", false);
    b.p("botId", () => input.botId, "{botId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeBotLocaleCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeBotRecommendationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/botrecommendations/{botRecommendationId}");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    b.p("botRecommendationId", () => input.botRecommendationId, "{botRecommendationId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeBotReplicaCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/bots/{botId}/replicas/{replicaRegion}");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("replicaRegion", () => input.replicaRegion, "{replicaRegion}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeBotResourceGenerationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/generations/{generationId}");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    b.p("generationId", () => input.generationId, "{generationId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeBotVersionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/bots/{botId}/botversions/{botVersion}");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeCustomVocabularyMetadataCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/customvocabulary/DEFAULT/metadata");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeExportCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/exports/{exportId}");
    b.p("exportId", () => input.exportId, "{exportId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeImportCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/imports/{importId}");
    b.p("importId", () => input.importId, "{importId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeIntentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents/{intentId}");
    b.p("intentId", () => input.intentId, "{intentId}", false);
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeResourcePolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/policy/{resourceArn}");
    b.p("resourceArn", () => input.resourceArn, "{resourceArn}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeSlotCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents/{intentId}/slots/{slotId}");
    b.p("slotId", () => input.slotId, "{slotId}", false);
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    b.p("intentId", () => input.intentId, "{intentId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeSlotTypeCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/slottypes/{slotTypeId}");
    b.p("slotTypeId", () => input.slotTypeId, "{slotTypeId}", false);
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeTestExecutionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/testexecutions/{testExecutionId}");
    b.p("testExecutionId", () => input.testExecutionId, "{testExecutionId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeTestSetCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/testsets/{testSetId}");
    b.p("testSetId", () => input.testSetId, "{testSetId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeTestSetDiscrepancyReportCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/testsetdiscrepancy/{testSetDiscrepancyReportId}");
    b.p("testSetDiscrepancyReportId", () => input.testSetDiscrepancyReportId, "{testSetDiscrepancyReportId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeTestSetGenerationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/testsetgenerations/{testSetGenerationId}");
    b.p("testSetGenerationId", () => input.testSetGenerationId, "{testSetGenerationId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GenerateBotElementCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/generate");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    let body;
    body = JSON.stringify(take(input, {
        intentId: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetTestExecutionArtifactsUrlCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/testexecutions/{testExecutionId}/artifacturl");
    b.p("testExecutionId", () => input.testExecutionId, "{testExecutionId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_ListAggregatedUtterancesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/aggregatedutterances");
    b.p("botId", () => input.botId, "{botId}", false);
    let body;
    body = JSON.stringify(take(input, {
        aggregationDuration: (_) => _json(_),
        botAliasId: [],
        botVersion: [],
        filters: (_) => _json(_),
        localeId: [],
        maxResults: [],
        nextToken: [],
        sortBy: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListBotAliasesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/botaliases");
    b.p("botId", () => input.botId, "{botId}", false);
    let body;
    body = JSON.stringify(take(input, {
        maxResults: [],
        nextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListBotAliasReplicasCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/replicas/{replicaRegion}/botaliases");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("replicaRegion", () => input.replicaRegion, "{replicaRegion}", false);
    let body;
    body = JSON.stringify(take(input, {
        maxResults: [],
        nextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListBotLocalesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    let body;
    body = JSON.stringify(take(input, {
        filters: (_) => _json(_),
        maxResults: [],
        nextToken: [],
        sortBy: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListBotRecommendationsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/botrecommendations");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    let body;
    body = JSON.stringify(take(input, {
        maxResults: [],
        nextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListBotReplicasCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/bots/{botId}/replicas");
    b.p("botId", () => input.botId, "{botId}", false);
    let body;
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListBotResourceGenerationsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/generations");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    let body;
    body = JSON.stringify(take(input, {
        maxResults: [],
        nextToken: [],
        sortBy: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListBotsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots");
    let body;
    body = JSON.stringify(take(input, {
        filters: (_) => _json(_),
        maxResults: [],
        nextToken: [],
        sortBy: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListBotVersionReplicasCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/replicas/{replicaRegion}/botversions");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("replicaRegion", () => input.replicaRegion, "{replicaRegion}", false);
    let body;
    body = JSON.stringify(take(input, {
        maxResults: [],
        nextToken: [],
        sortBy: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListBotVersionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/botversions");
    b.p("botId", () => input.botId, "{botId}", false);
    let body;
    body = JSON.stringify(take(input, {
        maxResults: [],
        nextToken: [],
        sortBy: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListBuiltInIntentsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/builtins/locales/{localeId}/intents");
    b.p("localeId", () => input.localeId, "{localeId}", false);
    let body;
    body = JSON.stringify(take(input, {
        maxResults: [],
        nextToken: [],
        sortBy: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListBuiltInSlotTypesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/builtins/locales/{localeId}/slottypes");
    b.p("localeId", () => input.localeId, "{localeId}", false);
    let body;
    body = JSON.stringify(take(input, {
        maxResults: [],
        nextToken: [],
        sortBy: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListCustomVocabularyItemsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/customvocabulary/DEFAULT/list");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    let body;
    body = JSON.stringify(take(input, {
        maxResults: [],
        nextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListExportsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/exports");
    let body;
    body = JSON.stringify(take(input, {
        botId: [],
        botVersion: [],
        filters: (_) => _json(_),
        localeId: [],
        maxResults: [],
        nextToken: [],
        sortBy: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListImportsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/imports");
    let body;
    body = JSON.stringify(take(input, {
        botId: [],
        botVersion: [],
        filters: (_) => _json(_),
        localeId: [],
        maxResults: [],
        nextToken: [],
        sortBy: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListIntentMetricsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/analytics/intentmetrics");
    b.p("botId", () => input.botId, "{botId}", false);
    let body;
    body = JSON.stringify(take(input, {
        binBy: (_) => _json(_),
        endDateTime: (_) => Math.round(_.getTime() / 1000),
        filters: (_) => _json(_),
        groupBy: (_) => _json(_),
        maxResults: [],
        metrics: (_) => _json(_),
        nextToken: [],
        startDateTime: (_) => Math.round(_.getTime() / 1000),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListIntentPathsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/analytics/intentpaths");
    b.p("botId", () => input.botId, "{botId}", false);
    let body;
    body = JSON.stringify(take(input, {
        endDateTime: (_) => Math.round(_.getTime() / 1000),
        filters: (_) => _json(_),
        intentPath: [],
        startDateTime: (_) => Math.round(_.getTime() / 1000),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListIntentsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    let body;
    body = JSON.stringify(take(input, {
        filters: (_) => _json(_),
        maxResults: [],
        nextToken: [],
        sortBy: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListIntentStageMetricsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/analytics/intentstagemetrics");
    b.p("botId", () => input.botId, "{botId}", false);
    let body;
    body = JSON.stringify(take(input, {
        binBy: (_) => _json(_),
        endDateTime: (_) => Math.round(_.getTime() / 1000),
        filters: (_) => _json(_),
        groupBy: (_) => _json(_),
        maxResults: [],
        metrics: (_) => _json(_),
        nextToken: [],
        startDateTime: (_) => Math.round(_.getTime() / 1000),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListRecommendedIntentsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/botrecommendations/{botRecommendationId}/intents");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    b.p("botRecommendationId", () => input.botRecommendationId, "{botRecommendationId}", false);
    let body;
    body = JSON.stringify(take(input, {
        maxResults: [],
        nextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListSessionAnalyticsDataCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/analytics/sessions");
    b.p("botId", () => input.botId, "{botId}", false);
    let body;
    body = JSON.stringify(take(input, {
        endDateTime: (_) => Math.round(_.getTime() / 1000),
        filters: (_) => _json(_),
        maxResults: [],
        nextToken: [],
        sortBy: (_) => _json(_),
        startDateTime: (_) => Math.round(_.getTime() / 1000),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListSessionMetricsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/analytics/sessionmetrics");
    b.p("botId", () => input.botId, "{botId}", false);
    let body;
    body = JSON.stringify(take(input, {
        binBy: (_) => _json(_),
        endDateTime: (_) => Math.round(_.getTime() / 1000),
        filters: (_) => _json(_),
        groupBy: (_) => _json(_),
        maxResults: [],
        metrics: (_) => _json(_),
        nextToken: [],
        startDateTime: (_) => Math.round(_.getTime() / 1000),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListSlotsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents/{intentId}/slots");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    b.p("intentId", () => input.intentId, "{intentId}", false);
    let body;
    body = JSON.stringify(take(input, {
        filters: (_) => _json(_),
        maxResults: [],
        nextToken: [],
        sortBy: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListSlotTypesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/slottypes");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    let body;
    body = JSON.stringify(take(input, {
        filters: (_) => _json(_),
        maxResults: [],
        nextToken: [],
        sortBy: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListTagsForResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/tags/{resourceARN}");
    b.p("resourceARN", () => input.resourceARN, "{resourceARN}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_ListTestExecutionResultItemsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/testexecutions/{testExecutionId}/results");
    b.p("testExecutionId", () => input.testExecutionId, "{testExecutionId}", false);
    let body;
    body = JSON.stringify(take(input, {
        maxResults: [],
        nextToken: [],
        resultFilterBy: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListTestExecutionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/testexecutions");
    let body;
    body = JSON.stringify(take(input, {
        maxResults: [],
        nextToken: [],
        sortBy: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListTestSetRecordsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/testsets/{testSetId}/records");
    b.p("testSetId", () => input.testSetId, "{testSetId}", false);
    let body;
    body = JSON.stringify(take(input, {
        maxResults: [],
        nextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListTestSetsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/testsets");
    let body;
    body = JSON.stringify(take(input, {
        maxResults: [],
        nextToken: [],
        sortBy: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListUtteranceAnalyticsDataCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/analytics/utterances");
    b.p("botId", () => input.botId, "{botId}", false);
    let body;
    body = JSON.stringify(take(input, {
        endDateTime: (_) => Math.round(_.getTime() / 1000),
        filters: (_) => _json(_),
        maxResults: [],
        nextToken: [],
        sortBy: (_) => _json(_),
        startDateTime: (_) => Math.round(_.getTime() / 1000),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListUtteranceMetricsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/analytics/utterancemetrics");
    b.p("botId", () => input.botId, "{botId}", false);
    let body;
    body = JSON.stringify(take(input, {
        attributes: (_) => _json(_),
        binBy: (_) => _json(_),
        endDateTime: (_) => Math.round(_.getTime() / 1000),
        filters: (_) => _json(_),
        groupBy: (_) => _json(_),
        maxResults: [],
        metrics: (_) => _json(_),
        nextToken: [],
        startDateTime: (_) => Math.round(_.getTime() / 1000),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_SearchAssociatedTranscriptsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/botrecommendations/{botRecommendationId}/associatedtranscripts");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    b.p("botRecommendationId", () => input.botRecommendationId, "{botRecommendationId}", false);
    let body;
    body = JSON.stringify(take(input, {
        filters: (_) => _json(_),
        maxResults: [],
        nextIndex: [],
        searchOrder: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_StartBotRecommendationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/botrecommendations");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    let body;
    body = JSON.stringify(take(input, {
        encryptionSetting: (_) => _json(_),
        transcriptSourceSetting: (_) => se_TranscriptSourceSetting(_, context),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_StartBotResourceGenerationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/startgeneration");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    let body;
    body = JSON.stringify(take(input, {
        generationInputPrompt: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_StartImportCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/imports");
    let body;
    body = JSON.stringify(take(input, {
        filePassword: [],
        importId: [],
        mergeStrategy: [],
        resourceSpecification: (_) => se_ImportResourceSpecification(_, context),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_StartTestExecutionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/testsets/{testSetId}/testexecutions");
    b.p("testSetId", () => input.testSetId, "{testSetId}", false);
    let body;
    body = JSON.stringify(take(input, {
        apiMode: [],
        target: (_) => _json(_),
        testExecutionModality: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_StartTestSetGenerationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/testsetgenerations");
    let body;
    body = JSON.stringify(take(input, {
        description: [],
        generationDataSource: (_) => se_TestSetGenerationDataSource(_, context),
        roleArn: [],
        storageLocation: (_) => _json(_),
        testSetName: [],
        testSetTags: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_StopBotRecommendationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/botrecommendations/{botRecommendationId}/stopbotrecommendation");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    b.p("botRecommendationId", () => input.botRecommendationId, "{botRecommendationId}", false);
    let body;
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_TagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/tags/{resourceARN}");
    b.p("resourceARN", () => input.resourceARN, "{resourceARN}", false);
    let body;
    body = JSON.stringify(take(input, {
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UntagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/tags/{resourceARN}");
    b.p("resourceARN", () => input.resourceARN, "{resourceARN}", false);
    const query = map({
        [_tK]: [
            __expectNonNull(input.tagKeys, `tagKeys`) != null,
            () => (input[_tK] || []).map((_entry) => _entry),
        ],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_UpdateBotCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}");
    b.p("botId", () => input.botId, "{botId}", false);
    let body;
    body = JSON.stringify(take(input, {
        botMembers: (_) => _json(_),
        botName: [],
        botType: [],
        dataPrivacy: (_) => _json(_),
        description: [],
        idleSessionTTLInSeconds: [],
        roleArn: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateBotAliasCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/botaliases/{botAliasId}");
    b.p("botAliasId", () => input.botAliasId, "{botAliasId}", false);
    b.p("botId", () => input.botId, "{botId}", false);
    let body;
    body = JSON.stringify(take(input, {
        botAliasLocaleSettings: (_) => _json(_),
        botAliasName: [],
        botVersion: [],
        conversationLogSettings: (_) => _json(_),
        description: [],
        sentimentAnalysisSettings: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateBotLocaleCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    let body;
    body = JSON.stringify(take(input, {
        description: [],
        generativeAISettings: (_) => _json(_),
        nluIntentConfidenceThreshold: (_) => __serializeFloat(_),
        voiceSettings: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateBotRecommendationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/botrecommendations/{botRecommendationId}");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    b.p("botRecommendationId", () => input.botRecommendationId, "{botRecommendationId}", false);
    let body;
    body = JSON.stringify(take(input, {
        encryptionSetting: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateExportCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/exports/{exportId}");
    b.p("exportId", () => input.exportId, "{exportId}", false);
    let body;
    body = JSON.stringify(take(input, {
        filePassword: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateIntentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents/{intentId}");
    b.p("intentId", () => input.intentId, "{intentId}", false);
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    let body;
    body = JSON.stringify(take(input, {
        description: [],
        dialogCodeHook: (_) => _json(_),
        fulfillmentCodeHook: (_) => se_FulfillmentCodeHookSettings(_, context),
        initialResponseSetting: (_) => se_InitialResponseSetting(_, context),
        inputContexts: (_) => _json(_),
        intentClosingSetting: (_) => se_IntentClosingSetting(_, context),
        intentConfirmationSetting: (_) => se_IntentConfirmationSetting(_, context),
        intentName: [],
        kendraConfiguration: (_) => _json(_),
        outputContexts: (_) => _json(_),
        parentIntentSignature: [],
        qnAIntentConfiguration: (_) => _json(_),
        sampleUtterances: (_) => _json(_),
        slotPriorities: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateResourcePolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/policy/{resourceArn}");
    b.p("resourceArn", () => input.resourceArn, "{resourceArn}", false);
    const query = map({
        [_eRI]: [, input[_eRI]],
    });
    let body;
    body = JSON.stringify(take(input, {
        policy: [],
    }));
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
export const se_UpdateSlotCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents/{intentId}/slots/{slotId}");
    b.p("slotId", () => input.slotId, "{slotId}", false);
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    b.p("intentId", () => input.intentId, "{intentId}", false);
    let body;
    body = JSON.stringify(take(input, {
        description: [],
        multipleValuesSetting: (_) => _json(_),
        obfuscationSetting: (_) => _json(_),
        slotName: [],
        slotTypeId: [],
        subSlotSetting: (_) => se_SubSlotSetting(_, context),
        valueElicitationSetting: (_) => se_SlotValueElicitationSetting(_, context),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateSlotTypeCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/slottypes/{slotTypeId}");
    b.p("slotTypeId", () => input.slotTypeId, "{slotTypeId}", false);
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botVersion", () => input.botVersion, "{botVersion}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    let body;
    body = JSON.stringify(take(input, {
        compositeSlotTypeSetting: (_) => _json(_),
        description: [],
        externalSourceSetting: (_) => _json(_),
        parentSlotTypeSignature: [],
        slotTypeName: [],
        slotTypeValues: (_) => _json(_),
        valueSelectionSetting: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateTestSetCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/testsets/{testSetId}");
    b.p("testSetId", () => input.testSetId, "{testSetId}", false);
    let body;
    body = JSON.stringify(take(input, {
        description: [],
        testSetName: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const de_BatchCreateCustomVocabularyItemCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botVersion: __expectString,
        errors: _json,
        localeId: __expectString,
        resources: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_BatchDeleteCustomVocabularyItemCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botVersion: __expectString,
        errors: _json,
        localeId: __expectString,
        resources: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_BatchUpdateCustomVocabularyItemCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botVersion: __expectString,
        errors: _json,
        localeId: __expectString,
        resources: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_BuildBotLocaleCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botLocaleStatus: __expectString,
        botVersion: __expectString,
        lastBuildSubmittedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        localeId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateBotCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botMembers: _json,
        botName: __expectString,
        botStatus: __expectString,
        botTags: _json,
        botType: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        dataPrivacy: _json,
        description: __expectString,
        idleSessionTTLInSeconds: __expectInt32,
        roleArn: __expectString,
        testBotAliasTags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateBotAliasCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botAliasId: __expectString,
        botAliasLocaleSettings: _json,
        botAliasName: __expectString,
        botAliasStatus: __expectString,
        botId: __expectString,
        botVersion: __expectString,
        conversationLogSettings: _json,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        sentimentAnalysisSettings: _json,
        tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateBotLocaleCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botLocaleStatus: __expectString,
        botVersion: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        generativeAISettings: _json,
        localeId: __expectString,
        localeName: __expectString,
        nluIntentConfidenceThreshold: __limitedParseDouble,
        voiceSettings: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateBotReplicaCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botReplicaStatus: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        replicaRegion: __expectString,
        sourceRegion: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateBotVersionCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botStatus: __expectString,
        botVersion: __expectString,
        botVersionLocaleSpecification: _json,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateExportCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        exportId: __expectString,
        exportStatus: __expectString,
        fileFormat: __expectString,
        resourceSpecification: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateIntentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botVersion: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        dialogCodeHook: _json,
        fulfillmentCodeHook: (_) => de_FulfillmentCodeHookSettings(_, context),
        initialResponseSetting: (_) => de_InitialResponseSetting(_, context),
        inputContexts: _json,
        intentClosingSetting: (_) => de_IntentClosingSetting(_, context),
        intentConfirmationSetting: (_) => de_IntentConfirmationSetting(_, context),
        intentId: __expectString,
        intentName: __expectString,
        kendraConfiguration: _json,
        localeId: __expectString,
        outputContexts: _json,
        parentIntentSignature: __expectString,
        qnAIntentConfiguration: _json,
        sampleUtterances: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateResourcePolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        resourceArn: __expectString,
        revisionId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateResourcePolicyStatementCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        resourceArn: __expectString,
        revisionId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateSlotCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botVersion: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        intentId: __expectString,
        localeId: __expectString,
        multipleValuesSetting: _json,
        obfuscationSetting: _json,
        slotId: __expectString,
        slotName: __expectString,
        slotTypeId: __expectString,
        subSlotSetting: (_) => de_SubSlotSetting(_, context),
        valueElicitationSetting: (_) => de_SlotValueElicitationSetting(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateSlotTypeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botVersion: __expectString,
        compositeSlotTypeSetting: _json,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        externalSourceSetting: _json,
        localeId: __expectString,
        parentSlotTypeSignature: __expectString,
        slotTypeId: __expectString,
        slotTypeName: __expectString,
        slotTypeValues: _json,
        valueSelectionSetting: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateTestSetDiscrepancyReportCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        target: _json,
        testSetDiscrepancyReportId: __expectString,
        testSetId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateUploadUrlCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        importId: __expectString,
        uploadUrl: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteBotCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botStatus: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteBotAliasCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botAliasId: __expectString,
        botAliasStatus: __expectString,
        botId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteBotLocaleCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botLocaleStatus: __expectString,
        botVersion: __expectString,
        localeId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteBotReplicaCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botReplicaStatus: __expectString,
        replicaRegion: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteBotVersionCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botStatus: __expectString,
        botVersion: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteCustomVocabularyCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botVersion: __expectString,
        customVocabularyStatus: __expectString,
        localeId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteExportCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        exportId: __expectString,
        exportStatus: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteImportCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        importId: __expectString,
        importStatus: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteIntentCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteResourcePolicyCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        resourceArn: __expectString,
        revisionId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteResourcePolicyStatementCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        resourceArn: __expectString,
        revisionId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteSlotCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteSlotTypeCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteTestSetCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteUtterancesCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DescribeBotCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botMembers: _json,
        botName: __expectString,
        botStatus: __expectString,
        botType: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        dataPrivacy: _json,
        description: __expectString,
        failureReasons: _json,
        idleSessionTTLInSeconds: __expectInt32,
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        roleArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeBotAliasCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botAliasHistoryEvents: (_) => de_BotAliasHistoryEventsList(_, context),
        botAliasId: __expectString,
        botAliasLocaleSettings: _json,
        botAliasName: __expectString,
        botAliasStatus: __expectString,
        botId: __expectString,
        botVersion: __expectString,
        conversationLogSettings: _json,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        parentBotNetworks: _json,
        sentimentAnalysisSettings: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeBotLocaleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botLocaleHistoryEvents: (_) => de_BotLocaleHistoryEventsList(_, context),
        botLocaleStatus: __expectString,
        botVersion: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        failureReasons: _json,
        generativeAISettings: _json,
        intentsCount: __expectInt32,
        lastBuildSubmittedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        localeId: __expectString,
        localeName: __expectString,
        nluIntentConfidenceThreshold: __limitedParseDouble,
        recommendedActions: _json,
        slotTypesCount: __expectInt32,
        voiceSettings: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeBotRecommendationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botRecommendationId: __expectString,
        botRecommendationResults: _json,
        botRecommendationStatus: __expectString,
        botVersion: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        encryptionSetting: _json,
        failureReasons: _json,
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        localeId: __expectString,
        transcriptSourceSetting: (_) => de_TranscriptSourceSetting(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeBotReplicaCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botReplicaStatus: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        failureReasons: _json,
        replicaRegion: __expectString,
        sourceRegion: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeBotResourceGenerationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botVersion: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        failureReasons: _json,
        generatedBotLocaleUrl: __expectString,
        generationId: __expectString,
        generationInputPrompt: __expectString,
        generationStatus: __expectString,
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        localeId: __expectString,
        modelArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeBotVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botMembers: _json,
        botName: __expectString,
        botStatus: __expectString,
        botType: __expectString,
        botVersion: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        dataPrivacy: _json,
        description: __expectString,
        failureReasons: _json,
        idleSessionTTLInSeconds: __expectInt32,
        parentBotNetworks: _json,
        roleArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeCustomVocabularyMetadataCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botVersion: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        customVocabularyStatus: __expectString,
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        localeId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeExportCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        downloadUrl: __expectString,
        exportId: __expectString,
        exportStatus: __expectString,
        failureReasons: _json,
        fileFormat: __expectString,
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        resourceSpecification: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeImportCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        failureReasons: _json,
        importId: __expectString,
        importStatus: __expectString,
        importedResourceId: __expectString,
        importedResourceName: __expectString,
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        mergeStrategy: __expectString,
        resourceSpecification: (_) => de_ImportResourceSpecification(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeIntentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botVersion: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        dialogCodeHook: _json,
        fulfillmentCodeHook: (_) => de_FulfillmentCodeHookSettings(_, context),
        initialResponseSetting: (_) => de_InitialResponseSetting(_, context),
        inputContexts: _json,
        intentClosingSetting: (_) => de_IntentClosingSetting(_, context),
        intentConfirmationSetting: (_) => de_IntentConfirmationSetting(_, context),
        intentId: __expectString,
        intentName: __expectString,
        kendraConfiguration: _json,
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        localeId: __expectString,
        outputContexts: _json,
        parentIntentSignature: __expectString,
        qnAIntentConfiguration: _json,
        sampleUtterances: _json,
        slotPriorities: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeResourcePolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        policy: __expectString,
        resourceArn: __expectString,
        revisionId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeSlotCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botVersion: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        intentId: __expectString,
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        localeId: __expectString,
        multipleValuesSetting: _json,
        obfuscationSetting: _json,
        slotId: __expectString,
        slotName: __expectString,
        slotTypeId: __expectString,
        subSlotSetting: (_) => de_SubSlotSetting(_, context),
        valueElicitationSetting: (_) => de_SlotValueElicitationSetting(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeSlotTypeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botVersion: __expectString,
        compositeSlotTypeSetting: _json,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        externalSourceSetting: _json,
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        localeId: __expectString,
        parentSlotTypeSignature: __expectString,
        slotTypeId: __expectString,
        slotTypeName: __expectString,
        slotTypeValues: _json,
        valueSelectionSetting: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeTestExecutionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiMode: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        failureReasons: _json,
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        target: _json,
        testExecutionId: __expectString,
        testExecutionModality: __expectString,
        testExecutionStatus: __expectString,
        testSetId: __expectString,
        testSetName: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeTestSetCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        modality: __expectString,
        numTurns: __expectInt32,
        roleArn: __expectString,
        status: __expectString,
        storageLocation: _json,
        testSetId: __expectString,
        testSetName: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeTestSetDiscrepancyReportCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        failureReasons: _json,
        lastUpdatedDataTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        target: _json,
        testSetDiscrepancyRawOutputUrl: __expectString,
        testSetDiscrepancyReportId: __expectString,
        testSetDiscrepancyReportStatus: __expectString,
        testSetDiscrepancyTopErrors: _json,
        testSetId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeTestSetGenerationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        failureReasons: _json,
        generationDataSource: (_) => de_TestSetGenerationDataSource(_, context),
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        roleArn: __expectString,
        storageLocation: _json,
        testSetGenerationId: __expectString,
        testSetGenerationStatus: __expectString,
        testSetId: __expectString,
        testSetName: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GenerateBotElementCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botVersion: __expectString,
        intentId: __expectString,
        localeId: __expectString,
        sampleUtterances: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetTestExecutionArtifactsUrlCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        downloadArtifactsUrl: __expectString,
        testExecutionId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListAggregatedUtterancesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        aggregatedUtterancesSummaries: (_) => de_AggregatedUtterancesSummaryList(_, context),
        aggregationDuration: _json,
        aggregationLastRefreshedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        aggregationWindowEndTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        aggregationWindowStartTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        botAliasId: __expectString,
        botId: __expectString,
        botVersion: __expectString,
        localeId: __expectString,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListBotAliasesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botAliasSummaries: (_) => de_BotAliasSummaryList(_, context),
        botId: __expectString,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListBotAliasReplicasCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botAliasReplicaSummaries: (_) => de_BotAliasReplicaSummaryList(_, context),
        botId: __expectString,
        nextToken: __expectString,
        replicaRegion: __expectString,
        sourceRegion: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListBotLocalesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botLocaleSummaries: (_) => de_BotLocaleSummaryList(_, context),
        botVersion: __expectString,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListBotRecommendationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botRecommendationSummaries: (_) => de_BotRecommendationSummaryList(_, context),
        botVersion: __expectString,
        localeId: __expectString,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListBotReplicasCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botReplicaSummaries: (_) => de_BotReplicaSummaryList(_, context),
        sourceRegion: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListBotResourceGenerationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botVersion: __expectString,
        generationSummaries: (_) => de_GenerationSummaryList(_, context),
        localeId: __expectString,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListBotsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botSummaries: (_) => de_BotSummaryList(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListBotVersionReplicasCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botVersionReplicaSummaries: (_) => de_BotVersionReplicaSummaryList(_, context),
        nextToken: __expectString,
        replicaRegion: __expectString,
        sourceRegion: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListBotVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botVersionSummaries: (_) => de_BotVersionSummaryList(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListBuiltInIntentsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        builtInIntentSummaries: _json,
        localeId: __expectString,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListBuiltInSlotTypesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        builtInSlotTypeSummaries: _json,
        localeId: __expectString,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListCustomVocabularyItemsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botVersion: __expectString,
        customVocabularyItems: _json,
        localeId: __expectString,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListExportsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botVersion: __expectString,
        exportSummaries: (_) => de_ExportSummaryList(_, context),
        localeId: __expectString,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListImportsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botVersion: __expectString,
        importSummaries: (_) => de_ImportSummaryList(_, context),
        localeId: __expectString,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListIntentMetricsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        nextToken: __expectString,
        results: (_) => de_AnalyticsIntentResults(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListIntentPathsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nodeSummaries: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListIntentsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botVersion: __expectString,
        intentSummaries: (_) => de_IntentSummaryList(_, context),
        localeId: __expectString,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListIntentStageMetricsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        nextToken: __expectString,
        results: (_) => de_AnalyticsIntentStageResults(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListRecommendedIntentsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botRecommendationId: __expectString,
        botVersion: __expectString,
        localeId: __expectString,
        nextToken: __expectString,
        summaryList: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListSessionAnalyticsDataCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        nextToken: __expectString,
        sessions: (_) => de_SessionSpecifications(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListSessionMetricsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        nextToken: __expectString,
        results: (_) => de_AnalyticsSessionResults(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListSlotsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botVersion: __expectString,
        intentId: __expectString,
        localeId: __expectString,
        nextToken: __expectString,
        slotSummaries: (_) => de_SlotSummaryList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListSlotTypesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botVersion: __expectString,
        localeId: __expectString,
        nextToken: __expectString,
        slotTypeSummaries: (_) => de_SlotTypeSummaryList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListTestExecutionResultItemsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        testExecutionResults: (_) => de_TestExecutionResultItems(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListTestExecutionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        testExecutions: (_) => de_TestExecutionSummaryList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListTestSetRecordsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        testSetRecords: (_) => de_TestSetTurnRecordList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListTestSetsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        testSets: (_) => de_TestSetSummaryList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListUtteranceAnalyticsDataCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        nextToken: __expectString,
        utterances: (_) => de_UtteranceSpecifications(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListUtteranceMetricsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        nextToken: __expectString,
        results: (_) => de_AnalyticsUtteranceResults(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_SearchAssociatedTranscriptsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        associatedTranscripts: _json,
        botId: __expectString,
        botRecommendationId: __expectString,
        botVersion: __expectString,
        localeId: __expectString,
        nextIndex: __expectInt32,
        totalResults: __expectInt32,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_StartBotRecommendationCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botRecommendationId: __expectString,
        botRecommendationStatus: __expectString,
        botVersion: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        encryptionSetting: _json,
        localeId: __expectString,
        transcriptSourceSetting: (_) => de_TranscriptSourceSetting(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_StartBotResourceGenerationCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botVersion: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        generationId: __expectString,
        generationInputPrompt: __expectString,
        generationStatus: __expectString,
        localeId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_StartImportCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        importId: __expectString,
        importStatus: __expectString,
        mergeStrategy: __expectString,
        resourceSpecification: (_) => de_ImportResourceSpecification(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_StartTestExecutionCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiMode: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        target: _json,
        testExecutionId: __expectString,
        testExecutionModality: __expectString,
        testSetId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_StartTestSetGenerationCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        generationDataSource: (_) => de_TestSetGenerationDataSource(_, context),
        roleArn: __expectString,
        storageLocation: _json,
        testSetGenerationId: __expectString,
        testSetGenerationStatus: __expectString,
        testSetName: __expectString,
        testSetTags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_StopBotRecommendationCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botRecommendationId: __expectString,
        botRecommendationStatus: __expectString,
        botVersion: __expectString,
        localeId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateBotCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botMembers: _json,
        botName: __expectString,
        botStatus: __expectString,
        botType: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        dataPrivacy: _json,
        description: __expectString,
        idleSessionTTLInSeconds: __expectInt32,
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        roleArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateBotAliasCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botAliasId: __expectString,
        botAliasLocaleSettings: _json,
        botAliasName: __expectString,
        botAliasStatus: __expectString,
        botId: __expectString,
        botVersion: __expectString,
        conversationLogSettings: _json,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        sentimentAnalysisSettings: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateBotLocaleCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botLocaleStatus: __expectString,
        botVersion: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        failureReasons: _json,
        generativeAISettings: _json,
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        localeId: __expectString,
        localeName: __expectString,
        nluIntentConfidenceThreshold: __limitedParseDouble,
        recommendedActions: _json,
        voiceSettings: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateBotRecommendationCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botRecommendationId: __expectString,
        botRecommendationStatus: __expectString,
        botVersion: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        encryptionSetting: _json,
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        localeId: __expectString,
        transcriptSourceSetting: (_) => de_TranscriptSourceSetting(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateExportCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        exportId: __expectString,
        exportStatus: __expectString,
        fileFormat: __expectString,
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        resourceSpecification: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateIntentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botVersion: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        dialogCodeHook: _json,
        fulfillmentCodeHook: (_) => de_FulfillmentCodeHookSettings(_, context),
        initialResponseSetting: (_) => de_InitialResponseSetting(_, context),
        inputContexts: _json,
        intentClosingSetting: (_) => de_IntentClosingSetting(_, context),
        intentConfirmationSetting: (_) => de_IntentConfirmationSetting(_, context),
        intentId: __expectString,
        intentName: __expectString,
        kendraConfiguration: _json,
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        localeId: __expectString,
        outputContexts: _json,
        parentIntentSignature: __expectString,
        qnAIntentConfiguration: _json,
        sampleUtterances: _json,
        slotPriorities: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateResourcePolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        resourceArn: __expectString,
        revisionId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateSlotCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botVersion: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        intentId: __expectString,
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        localeId: __expectString,
        multipleValuesSetting: _json,
        obfuscationSetting: _json,
        slotId: __expectString,
        slotName: __expectString,
        slotTypeId: __expectString,
        subSlotSetting: (_) => de_SubSlotSetting(_, context),
        valueElicitationSetting: (_) => de_SlotValueElicitationSetting(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateSlotTypeCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botId: __expectString,
        botVersion: __expectString,
        compositeSlotTypeSetting: _json,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        externalSourceSetting: _json,
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        localeId: __expectString,
        parentSlotTypeSignature: __expectString,
        slotTypeId: __expectString,
        slotTypeName: __expectString,
        slotTypeValues: _json,
        valueSelectionSetting: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateTestSetCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        modality: __expectString,
        numTurns: __expectInt32,
        roleArn: __expectString,
        status: __expectString,
        storageLocation: _json,
        testSetId: __expectString,
        testSetName: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.lexmodelsv2#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.lexmodelsv2#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceQuotaExceededException":
        case "com.amazonaws.lexmodelsv2#ServiceQuotaExceededException":
            throw await de_ServiceQuotaExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.lexmodelsv2#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.lexmodelsv2#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.lexmodelsv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "PreconditionFailedException":
        case "com.amazonaws.lexmodelsv2#PreconditionFailedException":
            throw await de_PreconditionFailedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = withBaseException(__BaseException);
const de_ConflictExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InternalServerExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InternalServerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_PreconditionFailedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new PreconditionFailedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ServiceQuotaExceededExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ServiceQuotaExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ThrottlingExceptionRes = async (parsedOutput, context) => {
    const contents = map({
        [_rAS]: [() => void 0 !== parsedOutput.headers[_ra], () => __strictParseInt32(parsedOutput.headers[_ra])],
    });
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ThrottlingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ValidationExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const se_BotLocaleImportSpecification = (input, context) => {
    return take(input, {
        botId: [],
        botVersion: [],
        localeId: [],
        nluIntentConfidenceThreshold: __serializeFloat,
        voiceSettings: _json,
    });
};
const se_ConditionalBranch = (input, context) => {
    return take(input, {
        condition: _json,
        name: [],
        nextStep: (_) => se_DialogState(_, context),
        response: _json,
    });
};
const se_ConditionalBranches = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_ConditionalBranch(entry, context);
    });
};
const se_ConditionalSpecification = (input, context) => {
    return take(input, {
        active: [],
        conditionalBranches: (_) => se_ConditionalBranches(_, context),
        defaultBranch: (_) => se_DefaultConditionalBranch(_, context),
    });
};
const se_ConversationLogsDataSource = (input, context) => {
    return take(input, {
        botAliasId: [],
        botId: [],
        filter: (_) => se_ConversationLogsDataSourceFilterBy(_, context),
        localeId: [],
    });
};
const se_ConversationLogsDataSourceFilterBy = (input, context) => {
    return take(input, {
        endTime: (_) => Math.round(_.getTime() / 1000),
        inputMode: [],
        startTime: (_) => Math.round(_.getTime() / 1000),
    });
};
const se_DateRangeFilter = (input, context) => {
    return take(input, {
        endDateTime: (_) => Math.round(_.getTime() / 1000),
        startDateTime: (_) => Math.round(_.getTime() / 1000),
    });
};
const se_DefaultConditionalBranch = (input, context) => {
    return take(input, {
        nextStep: (_) => se_DialogState(_, context),
        response: _json,
    });
};
const se_DialogCodeHookInvocationSetting = (input, context) => {
    return take(input, {
        active: [],
        enableCodeHookInvocation: [],
        invocationLabel: [],
        postCodeHookSpecification: (_) => se_PostDialogCodeHookInvocationSpecification(_, context),
    });
};
const se_DialogState = (input, context) => {
    return take(input, {
        dialogAction: _json,
        intent: (_) => se_IntentOverride(_, context),
        sessionAttributes: _json,
    });
};
const se_FulfillmentCodeHookSettings = (input, context) => {
    return take(input, {
        active: [],
        enabled: [],
        fulfillmentUpdatesSpecification: _json,
        postFulfillmentStatusSpecification: (_) => se_PostFulfillmentStatusSpecification(_, context),
    });
};
const se_ImportResourceSpecification = (input, context) => {
    return take(input, {
        botImportSpecification: _json,
        botLocaleImportSpecification: (_) => se_BotLocaleImportSpecification(_, context),
        customVocabularyImportSpecification: _json,
        testSetImportResourceSpecification: _json,
    });
};
const se_InitialResponseSetting = (input, context) => {
    return take(input, {
        codeHook: (_) => se_DialogCodeHookInvocationSetting(_, context),
        conditional: (_) => se_ConditionalSpecification(_, context),
        initialResponse: _json,
        nextStep: (_) => se_DialogState(_, context),
    });
};
const se_IntentClosingSetting = (input, context) => {
    return take(input, {
        active: [],
        closingResponse: _json,
        conditional: (_) => se_ConditionalSpecification(_, context),
        nextStep: (_) => se_DialogState(_, context),
    });
};
const se_IntentConfirmationSetting = (input, context) => {
    return take(input, {
        active: [],
        codeHook: (_) => se_DialogCodeHookInvocationSetting(_, context),
        confirmationConditional: (_) => se_ConditionalSpecification(_, context),
        confirmationNextStep: (_) => se_DialogState(_, context),
        confirmationResponse: _json,
        declinationConditional: (_) => se_ConditionalSpecification(_, context),
        declinationNextStep: (_) => se_DialogState(_, context),
        declinationResponse: _json,
        elicitationCodeHook: _json,
        failureConditional: (_) => se_ConditionalSpecification(_, context),
        failureNextStep: (_) => se_DialogState(_, context),
        failureResponse: _json,
        promptSpecification: _json,
    });
};
const se_IntentOverride = (input, context) => {
    return take(input, {
        name: [],
        slots: (_) => se_SlotValueOverrideMap(_, context),
    });
};
const se_LexTranscriptFilter = (input, context) => {
    return take(input, {
        dateRangeFilter: (_) => se_DateRangeFilter(_, context),
    });
};
const se_PostDialogCodeHookInvocationSpecification = (input, context) => {
    return take(input, {
        failureConditional: (_) => se_ConditionalSpecification(_, context),
        failureNextStep: (_) => se_DialogState(_, context),
        failureResponse: _json,
        successConditional: (_) => se_ConditionalSpecification(_, context),
        successNextStep: (_) => se_DialogState(_, context),
        successResponse: _json,
        timeoutConditional: (_) => se_ConditionalSpecification(_, context),
        timeoutNextStep: (_) => se_DialogState(_, context),
        timeoutResponse: _json,
    });
};
const se_PostFulfillmentStatusSpecification = (input, context) => {
    return take(input, {
        failureConditional: (_) => se_ConditionalSpecification(_, context),
        failureNextStep: (_) => se_DialogState(_, context),
        failureResponse: _json,
        successConditional: (_) => se_ConditionalSpecification(_, context),
        successNextStep: (_) => se_DialogState(_, context),
        successResponse: _json,
        timeoutConditional: (_) => se_ConditionalSpecification(_, context),
        timeoutNextStep: (_) => se_DialogState(_, context),
        timeoutResponse: _json,
    });
};
const se_S3BucketTranscriptSource = (input, context) => {
    return take(input, {
        kmsKeyArn: [],
        pathFormat: _json,
        s3BucketName: [],
        transcriptFilter: (_) => se_TranscriptFilter(_, context),
        transcriptFormat: [],
    });
};
const se_SlotCaptureSetting = (input, context) => {
    return take(input, {
        captureConditional: (_) => se_ConditionalSpecification(_, context),
        captureNextStep: (_) => se_DialogState(_, context),
        captureResponse: _json,
        codeHook: (_) => se_DialogCodeHookInvocationSetting(_, context),
        elicitationCodeHook: _json,
        failureConditional: (_) => se_ConditionalSpecification(_, context),
        failureNextStep: (_) => se_DialogState(_, context),
        failureResponse: _json,
    });
};
const se_SlotValueElicitationSetting = (input, context) => {
    return take(input, {
        defaultValueSpecification: _json,
        promptSpecification: _json,
        sampleUtterances: _json,
        slotCaptureSetting: (_) => se_SlotCaptureSetting(_, context),
        slotConstraint: [],
        slotResolutionSetting: _json,
        waitAndContinueSpecification: _json,
    });
};
const se_SlotValueOverride = (input, context) => {
    return take(input, {
        shape: [],
        value: _json,
        values: (_) => se_SlotValues(_, context),
    });
};
const se_SlotValueOverrideMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_SlotValueOverride(value, context);
        return acc;
    }, {});
};
const se_SlotValues = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_SlotValueOverride(entry, context);
    });
};
const se_Specifications = (input, context) => {
    return take(input, {
        slotTypeId: [],
        valueElicitationSetting: _json,
    });
};
const se_SubSlotSetting = (input, context) => {
    return take(input, {
        expression: [],
        slotSpecifications: (_) => se_SubSlotSpecificationMap(_, context),
    });
};
const se_SubSlotSpecificationMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_Specifications(value, context);
        return acc;
    }, {});
};
const se_TestSetGenerationDataSource = (input, context) => {
    return take(input, {
        conversationLogsDataSource: (_) => se_ConversationLogsDataSource(_, context),
    });
};
const se_TranscriptFilter = (input, context) => {
    return take(input, {
        lexTranscriptFilter: (_) => se_LexTranscriptFilter(_, context),
    });
};
const se_TranscriptSourceSetting = (input, context) => {
    return take(input, {
        s3BucketTranscriptSource: (_) => se_S3BucketTranscriptSource(_, context),
    });
};
const de_AggregatedUtterancesSummary = (output, context) => {
    return take(output, {
        containsDataFromDeletedResources: __expectBoolean,
        hitCount: __expectInt32,
        missedCount: __expectInt32,
        utterance: __expectString,
        utteranceFirstRecordedInAggregationDuration: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        utteranceLastRecordedInAggregationDuration: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_AggregatedUtterancesSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AggregatedUtterancesSummary(entry, context);
    });
    return retVal;
};
const de_AnalyticsIntentMetricResult = (output, context) => {
    return take(output, {
        name: __expectString,
        statistic: __expectString,
        value: __limitedParseDouble,
    });
};
const de_AnalyticsIntentMetricResults = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AnalyticsIntentMetricResult(entry, context);
    });
    return retVal;
};
const de_AnalyticsIntentResult = (output, context) => {
    return take(output, {
        binKeys: _json,
        groupByKeys: _json,
        metricsResults: (_) => de_AnalyticsIntentMetricResults(_, context),
    });
};
const de_AnalyticsIntentResults = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AnalyticsIntentResult(entry, context);
    });
    return retVal;
};
const de_AnalyticsIntentStageMetricResult = (output, context) => {
    return take(output, {
        name: __expectString,
        statistic: __expectString,
        value: __limitedParseDouble,
    });
};
const de_AnalyticsIntentStageMetricResults = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AnalyticsIntentStageMetricResult(entry, context);
    });
    return retVal;
};
const de_AnalyticsIntentStageResult = (output, context) => {
    return take(output, {
        binKeys: _json,
        groupByKeys: _json,
        metricsResults: (_) => de_AnalyticsIntentStageMetricResults(_, context),
    });
};
const de_AnalyticsIntentStageResults = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AnalyticsIntentStageResult(entry, context);
    });
    return retVal;
};
const de_AnalyticsSessionMetricResult = (output, context) => {
    return take(output, {
        name: __expectString,
        statistic: __expectString,
        value: __limitedParseDouble,
    });
};
const de_AnalyticsSessionMetricResults = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AnalyticsSessionMetricResult(entry, context);
    });
    return retVal;
};
const de_AnalyticsSessionResult = (output, context) => {
    return take(output, {
        binKeys: _json,
        groupByKeys: _json,
        metricsResults: (_) => de_AnalyticsSessionMetricResults(_, context),
    });
};
const de_AnalyticsSessionResults = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AnalyticsSessionResult(entry, context);
    });
    return retVal;
};
const de_AnalyticsUtteranceMetricResult = (output, context) => {
    return take(output, {
        name: __expectString,
        statistic: __expectString,
        value: __limitedParseDouble,
    });
};
const de_AnalyticsUtteranceMetricResults = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AnalyticsUtteranceMetricResult(entry, context);
    });
    return retVal;
};
const de_AnalyticsUtteranceResult = (output, context) => {
    return take(output, {
        attributeResults: _json,
        binKeys: _json,
        groupByKeys: _json,
        metricsResults: (_) => de_AnalyticsUtteranceMetricResults(_, context),
    });
};
const de_AnalyticsUtteranceResults = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AnalyticsUtteranceResult(entry, context);
    });
    return retVal;
};
const de_BotAliasHistoryEvent = (output, context) => {
    return take(output, {
        botVersion: __expectString,
        endDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        startDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_BotAliasHistoryEventsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BotAliasHistoryEvent(entry, context);
    });
    return retVal;
};
const de_BotAliasReplicaSummary = (output, context) => {
    return take(output, {
        botAliasId: __expectString,
        botAliasReplicationStatus: __expectString,
        botVersion: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        failureReasons: _json,
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_BotAliasReplicaSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BotAliasReplicaSummary(entry, context);
    });
    return retVal;
};
const de_BotAliasSummary = (output, context) => {
    return take(output, {
        botAliasId: __expectString,
        botAliasName: __expectString,
        botAliasStatus: __expectString,
        botVersion: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_BotAliasSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BotAliasSummary(entry, context);
    });
    return retVal;
};
const de_BotLocaleHistoryEvent = (output, context) => {
    return take(output, {
        event: __expectString,
        eventDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_BotLocaleHistoryEventsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BotLocaleHistoryEvent(entry, context);
    });
    return retVal;
};
const de_BotLocaleImportSpecification = (output, context) => {
    return take(output, {
        botId: __expectString,
        botVersion: __expectString,
        localeId: __expectString,
        nluIntentConfidenceThreshold: __limitedParseDouble,
        voiceSettings: _json,
    });
};
const de_BotLocaleSummary = (output, context) => {
    return take(output, {
        botLocaleStatus: __expectString,
        description: __expectString,
        lastBuildSubmittedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        localeId: __expectString,
        localeName: __expectString,
    });
};
const de_BotLocaleSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BotLocaleSummary(entry, context);
    });
    return retVal;
};
const de_BotRecommendationSummary = (output, context) => {
    return take(output, {
        botRecommendationId: __expectString,
        botRecommendationStatus: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_BotRecommendationSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BotRecommendationSummary(entry, context);
    });
    return retVal;
};
const de_BotReplicaSummary = (output, context) => {
    return take(output, {
        botReplicaStatus: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        failureReasons: _json,
        replicaRegion: __expectString,
    });
};
const de_BotReplicaSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BotReplicaSummary(entry, context);
    });
    return retVal;
};
const de_BotSummary = (output, context) => {
    return take(output, {
        botId: __expectString,
        botName: __expectString,
        botStatus: __expectString,
        botType: __expectString,
        description: __expectString,
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        latestBotVersion: __expectString,
    });
};
const de_BotSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BotSummary(entry, context);
    });
    return retVal;
};
const de_BotVersionReplicaSummary = (output, context) => {
    return take(output, {
        botVersion: __expectString,
        botVersionReplicationStatus: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        failureReasons: _json,
    });
};
const de_BotVersionReplicaSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BotVersionReplicaSummary(entry, context);
    });
    return retVal;
};
const de_BotVersionSummary = (output, context) => {
    return take(output, {
        botName: __expectString,
        botStatus: __expectString,
        botVersion: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
    });
};
const de_BotVersionSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BotVersionSummary(entry, context);
    });
    return retVal;
};
const de_ConditionalBranch = (output, context) => {
    return take(output, {
        condition: _json,
        name: __expectString,
        nextStep: (_) => de_DialogState(_, context),
        response: _json,
    });
};
const de_ConditionalBranches = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ConditionalBranch(entry, context);
    });
    return retVal;
};
const de_ConditionalSpecification = (output, context) => {
    return take(output, {
        active: __expectBoolean,
        conditionalBranches: (_) => de_ConditionalBranches(_, context),
        defaultBranch: (_) => de_DefaultConditionalBranch(_, context),
    });
};
const de_ConversationLogsDataSource = (output, context) => {
    return take(output, {
        botAliasId: __expectString,
        botId: __expectString,
        filter: (_) => de_ConversationLogsDataSourceFilterBy(_, context),
        localeId: __expectString,
    });
};
const de_ConversationLogsDataSourceFilterBy = (output, context) => {
    return take(output, {
        endTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        inputMode: __expectString,
        startTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_DateRangeFilter = (output, context) => {
    return take(output, {
        endDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        startDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_DefaultConditionalBranch = (output, context) => {
    return take(output, {
        nextStep: (_) => de_DialogState(_, context),
        response: _json,
    });
};
const de_DialogCodeHookInvocationSetting = (output, context) => {
    return take(output, {
        active: __expectBoolean,
        enableCodeHookInvocation: __expectBoolean,
        invocationLabel: __expectString,
        postCodeHookSpecification: (_) => de_PostDialogCodeHookInvocationSpecification(_, context),
    });
};
const de_DialogState = (output, context) => {
    return take(output, {
        dialogAction: _json,
        intent: (_) => de_IntentOverride(_, context),
        sessionAttributes: _json,
    });
};
const de_ExportSummary = (output, context) => {
    return take(output, {
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        exportId: __expectString,
        exportStatus: __expectString,
        fileFormat: __expectString,
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        resourceSpecification: _json,
    });
};
const de_ExportSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ExportSummary(entry, context);
    });
    return retVal;
};
const de_FulfillmentCodeHookSettings = (output, context) => {
    return take(output, {
        active: __expectBoolean,
        enabled: __expectBoolean,
        fulfillmentUpdatesSpecification: _json,
        postFulfillmentStatusSpecification: (_) => de_PostFulfillmentStatusSpecification(_, context),
    });
};
const de_GenerationSummary = (output, context) => {
    return take(output, {
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        generationId: __expectString,
        generationStatus: __expectString,
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_GenerationSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_GenerationSummary(entry, context);
    });
    return retVal;
};
const de_ImportResourceSpecification = (output, context) => {
    return take(output, {
        botImportSpecification: _json,
        botLocaleImportSpecification: (_) => de_BotLocaleImportSpecification(_, context),
        customVocabularyImportSpecification: _json,
        testSetImportResourceSpecification: _json,
    });
};
const de_ImportSummary = (output, context) => {
    return take(output, {
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        importId: __expectString,
        importStatus: __expectString,
        importedResourceId: __expectString,
        importedResourceName: __expectString,
        importedResourceType: __expectString,
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        mergeStrategy: __expectString,
    });
};
const de_ImportSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ImportSummary(entry, context);
    });
    return retVal;
};
const de_InitialResponseSetting = (output, context) => {
    return take(output, {
        codeHook: (_) => de_DialogCodeHookInvocationSetting(_, context),
        conditional: (_) => de_ConditionalSpecification(_, context),
        initialResponse: _json,
        nextStep: (_) => de_DialogState(_, context),
    });
};
const de_InputSessionStateSpecification = (output, context) => {
    return take(output, {
        activeContexts: _json,
        runtimeHints: (_) => de_RuntimeHints(_, context),
        sessionAttributes: _json,
    });
};
const de_IntentClosingSetting = (output, context) => {
    return take(output, {
        active: __expectBoolean,
        closingResponse: _json,
        conditional: (_) => de_ConditionalSpecification(_, context),
        nextStep: (_) => de_DialogState(_, context),
    });
};
const de_IntentConfirmationSetting = (output, context) => {
    return take(output, {
        active: __expectBoolean,
        codeHook: (_) => de_DialogCodeHookInvocationSetting(_, context),
        confirmationConditional: (_) => de_ConditionalSpecification(_, context),
        confirmationNextStep: (_) => de_DialogState(_, context),
        confirmationResponse: _json,
        declinationConditional: (_) => de_ConditionalSpecification(_, context),
        declinationNextStep: (_) => de_DialogState(_, context),
        declinationResponse: _json,
        elicitationCodeHook: _json,
        failureConditional: (_) => de_ConditionalSpecification(_, context),
        failureNextStep: (_) => de_DialogState(_, context),
        failureResponse: _json,
        promptSpecification: _json,
    });
};
const de_IntentOverride = (output, context) => {
    return take(output, {
        name: __expectString,
        slots: (_) => de_SlotValueOverrideMap(_, context),
    });
};
const de_IntentSummary = (output, context) => {
    return take(output, {
        description: __expectString,
        inputContexts: _json,
        intentId: __expectString,
        intentName: __expectString,
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        outputContexts: _json,
        parentIntentSignature: __expectString,
    });
};
const de_IntentSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IntentSummary(entry, context);
    });
    return retVal;
};
const de_LexTranscriptFilter = (output, context) => {
    return take(output, {
        dateRangeFilter: (_) => de_DateRangeFilter(_, context),
    });
};
const de_PostDialogCodeHookInvocationSpecification = (output, context) => {
    return take(output, {
        failureConditional: (_) => de_ConditionalSpecification(_, context),
        failureNextStep: (_) => de_DialogState(_, context),
        failureResponse: _json,
        successConditional: (_) => de_ConditionalSpecification(_, context),
        successNextStep: (_) => de_DialogState(_, context),
        successResponse: _json,
        timeoutConditional: (_) => de_ConditionalSpecification(_, context),
        timeoutNextStep: (_) => de_DialogState(_, context),
        timeoutResponse: _json,
    });
};
const de_PostFulfillmentStatusSpecification = (output, context) => {
    return take(output, {
        failureConditional: (_) => de_ConditionalSpecification(_, context),
        failureNextStep: (_) => de_DialogState(_, context),
        failureResponse: _json,
        successConditional: (_) => de_ConditionalSpecification(_, context),
        successNextStep: (_) => de_DialogState(_, context),
        successResponse: _json,
        timeoutConditional: (_) => de_ConditionalSpecification(_, context),
        timeoutNextStep: (_) => de_DialogState(_, context),
        timeoutResponse: _json,
    });
};
const de_RuntimeHintDetails = (output, context) => {
    return take(output, {
        runtimeHintValues: _json,
        subSlotHints: (_) => de_SlotHintsSlotMap(_, context),
    });
};
const de_RuntimeHints = (output, context) => {
    return take(output, {
        slotHints: (_) => de_SlotHintsIntentMap(_, context),
    });
};
const de_S3BucketTranscriptSource = (output, context) => {
    return take(output, {
        kmsKeyArn: __expectString,
        pathFormat: _json,
        s3BucketName: __expectString,
        transcriptFilter: (_) => de_TranscriptFilter(_, context),
        transcriptFormat: __expectString,
    });
};
const de_SessionSpecification = (output, context) => {
    return take(output, {
        botAliasId: __expectString,
        botVersion: __expectString,
        channel: __expectString,
        conversationDurationSeconds: __expectLong,
        conversationEndState: __expectString,
        conversationEndTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        conversationStartTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        invokedIntentSamples: _json,
        localeId: __expectString,
        mode: __expectString,
        numberOfTurns: __expectLong,
        originatingRequestId: __expectString,
        sessionId: __expectString,
    });
};
const de_SessionSpecifications = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SessionSpecification(entry, context);
    });
    return retVal;
};
const de_SlotCaptureSetting = (output, context) => {
    return take(output, {
        captureConditional: (_) => de_ConditionalSpecification(_, context),
        captureNextStep: (_) => de_DialogState(_, context),
        captureResponse: _json,
        codeHook: (_) => de_DialogCodeHookInvocationSetting(_, context),
        elicitationCodeHook: _json,
        failureConditional: (_) => de_ConditionalSpecification(_, context),
        failureNextStep: (_) => de_DialogState(_, context),
        failureResponse: _json,
    });
};
const de_SlotHintsIntentMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_SlotHintsSlotMap(value, context);
        return acc;
    }, {});
};
const de_SlotHintsSlotMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_RuntimeHintDetails(value, context);
        return acc;
    }, {});
};
const de_SlotSummary = (output, context) => {
    return take(output, {
        description: __expectString,
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        slotConstraint: __expectString,
        slotId: __expectString,
        slotName: __expectString,
        slotTypeId: __expectString,
        valueElicitationPromptSpecification: _json,
    });
};
const de_SlotSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SlotSummary(entry, context);
    });
    return retVal;
};
const de_SlotTypeSummary = (output, context) => {
    return take(output, {
        description: __expectString,
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        parentSlotTypeSignature: __expectString,
        slotTypeCategory: __expectString,
        slotTypeId: __expectString,
        slotTypeName: __expectString,
    });
};
const de_SlotTypeSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SlotTypeSummary(entry, context);
    });
    return retVal;
};
const de_SlotValueElicitationSetting = (output, context) => {
    return take(output, {
        defaultValueSpecification: _json,
        promptSpecification: _json,
        sampleUtterances: _json,
        slotCaptureSetting: (_) => de_SlotCaptureSetting(_, context),
        slotConstraint: __expectString,
        slotResolutionSetting: _json,
        waitAndContinueSpecification: _json,
    });
};
const de_SlotValueOverride = (output, context) => {
    return take(output, {
        shape: __expectString,
        value: _json,
        values: (_) => de_SlotValues(_, context),
    });
};
const de_SlotValueOverrideMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_SlotValueOverride(value, context);
        return acc;
    }, {});
};
const de_SlotValues = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SlotValueOverride(entry, context);
    });
    return retVal;
};
const de_Specifications = (output, context) => {
    return take(output, {
        slotTypeId: __expectString,
        valueElicitationSetting: _json,
    });
};
const de_SubSlotSetting = (output, context) => {
    return take(output, {
        expression: __expectString,
        slotSpecifications: (_) => de_SubSlotSpecificationMap(_, context),
    });
};
const de_SubSlotSpecificationMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_Specifications(value, context);
        return acc;
    }, {});
};
const de_TestExecutionResultItems = (output, context) => {
    return take(output, {
        conversationLevelTestResults: _json,
        intentClassificationTestResults: _json,
        intentLevelSlotResolutionTestResults: _json,
        overallTestResults: _json,
        utteranceLevelTestResults: (_) => de_UtteranceLevelTestResults(_, context),
    });
};
const de_TestExecutionSummary = (output, context) => {
    return take(output, {
        apiMode: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        target: _json,
        testExecutionId: __expectString,
        testExecutionModality: __expectString,
        testExecutionStatus: __expectString,
        testSetId: __expectString,
        testSetName: __expectString,
    });
};
const de_TestExecutionSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TestExecutionSummary(entry, context);
    });
    return retVal;
};
const de_TestSetGenerationDataSource = (output, context) => {
    return take(output, {
        conversationLogsDataSource: (_) => de_ConversationLogsDataSource(_, context),
    });
};
const de_TestSetSummary = (output, context) => {
    return take(output, {
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        lastUpdatedDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        modality: __expectString,
        numTurns: __expectInt32,
        roleArn: __expectString,
        status: __expectString,
        storageLocation: _json,
        testSetId: __expectString,
        testSetName: __expectString,
    });
};
const de_TestSetSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TestSetSummary(entry, context);
    });
    return retVal;
};
const de_TestSetTurnRecord = (output, context) => {
    return take(output, {
        conversationId: __expectString,
        recordNumber: __expectLong,
        turnNumber: __expectInt32,
        turnSpecification: (_) => de_TurnSpecification(_, context),
    });
};
const de_TestSetTurnRecordList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TestSetTurnRecord(entry, context);
    });
    return retVal;
};
const de_TestSetTurnResult = (output, context) => {
    return take(output, {
        agent: _json,
        user: (_) => de_UserTurnResult(_, context),
    });
};
const de_TranscriptFilter = (output, context) => {
    return take(output, {
        lexTranscriptFilter: (_) => de_LexTranscriptFilter(_, context),
    });
};
const de_TranscriptSourceSetting = (output, context) => {
    return take(output, {
        s3BucketTranscriptSource: (_) => de_S3BucketTranscriptSource(_, context),
    });
};
const de_TurnSpecification = (output, context) => {
    return take(output, {
        agentTurn: _json,
        userTurn: (_) => de_UserTurnSpecification(_, context),
    });
};
const de_UserTurnInputSpecification = (output, context) => {
    return take(output, {
        requestAttributes: _json,
        sessionState: (_) => de_InputSessionStateSpecification(_, context),
        utteranceInput: _json,
    });
};
const de_UserTurnIntentOutput = (output, context) => {
    return take(output, {
        name: __expectString,
        slots: (_) => de_UserTurnSlotOutputMap(_, context),
    });
};
const de_UserTurnOutputSpecification = (output, context) => {
    return take(output, {
        activeContexts: _json,
        intent: (_) => de_UserTurnIntentOutput(_, context),
        transcript: __expectString,
    });
};
const de_UserTurnResult = (output, context) => {
    return take(output, {
        actualOutput: (_) => de_UserTurnOutputSpecification(_, context),
        conversationLevelResult: _json,
        endToEndResult: __expectString,
        errorDetails: _json,
        expectedOutput: (_) => de_UserTurnOutputSpecification(_, context),
        input: (_) => de_UserTurnInputSpecification(_, context),
        intentMatchResult: __expectString,
        slotMatchResult: __expectString,
        speechTranscriptionResult: __expectString,
    });
};
const de_UserTurnSlotOutput = (output, context) => {
    return take(output, {
        subSlots: (_) => de_UserTurnSlotOutputMap(_, context),
        value: __expectString,
        values: (_) => de_UserTurnSlotOutputList(_, context),
    });
};
const de_UserTurnSlotOutputList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_UserTurnSlotOutput(entry, context);
    });
    return retVal;
};
const de_UserTurnSlotOutputMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_UserTurnSlotOutput(value, context);
        return acc;
    }, {});
};
const de_UserTurnSpecification = (output, context) => {
    return take(output, {
        expected: (_) => de_UserTurnOutputSpecification(_, context),
        input: (_) => de_UserTurnInputSpecification(_, context),
    });
};
const de_UtteranceLevelTestResultItem = (output, context) => {
    return take(output, {
        conversationId: __expectString,
        recordNumber: __expectLong,
        turnResult: (_) => de_TestSetTurnResult(_, context),
    });
};
const de_UtteranceLevelTestResultItemList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_UtteranceLevelTestResultItem(entry, context);
    });
    return retVal;
};
const de_UtteranceLevelTestResults = (output, context) => {
    return take(output, {
        items: (_) => de_UtteranceLevelTestResultItemList(_, context),
    });
};
const de_UtteranceSpecification = (output, context) => {
    return take(output, {
        associatedIntentName: __expectString,
        associatedSlotName: __expectString,
        audioVoiceDurationMillis: __expectLong,
        botAliasId: __expectString,
        botResponseAudioVoiceId: __expectString,
        botResponses: _json,
        botVersion: __expectString,
        channel: __expectString,
        conversationEndTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        conversationStartTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        dialogActionType: __expectString,
        inputType: __expectString,
        intentState: __expectString,
        localeId: __expectString,
        mode: __expectString,
        outputType: __expectString,
        sessionId: __expectString,
        slotsFilledInSession: __expectString,
        utterance: __expectString,
        utteranceRequestId: __expectString,
        utteranceTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        utteranceUnderstood: __expectBoolean,
    });
};
const de_UtteranceSpecifications = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_UtteranceSpecification(entry, context);
    });
    return retVal;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const _eRI = "expectedRevisionId";
const _lI = "localeId";
const _rAS = "retryAfterSeconds";
const _ra = "retry-after";
const _sI = "sessionId";
const _sRIUC = "skipResourceInUseCheck";
const _tK = "tagKeys";
